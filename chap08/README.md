# 08. 다양한 API

## 08-1. 드래그 & 드롭 API

### draggable 속성
웹에서 드래그 할 수 있으려면 웹 요소를 draggable 속성을 이용해 드래그 할 수 있게 만들어야 합니다.

```html
<div draggable="true">drag me</div>
```

한 가지 명심할 점은 텍스트나 기타 요소들을 드래그 가능하게 만들면 더 이상 마우스로 클릭하거나 드래그하는 방법으로 텍스트를 선택할 수 없게 된다는 것입니다.

### 드래그 데이터
모든 드래그 이벤트는 dataTransfer라는 객체에 드래그 데이터와 함께 저장되어 있습니다. 드래그 데이터란 드래그 이벤트가 발생했을 때 드래그되는 대상을 가리킵니다.
드래그 데이터에는 데이터 유형(형식, 포맷)과 데이터 값, 이렇게 두 가지 정보가 들어있습니다. 데이터 유형이란 텍스트인지 URL인지를 구분하는 것이고, 데이터 값은 실제 데이터 내용을 말합니다.
예를 들어 링크 URL이 드래그 데이터라면 데이터 유형은 URL이고 데이터 값은 링크 주소가 될 것입니다.

### 파일 유형
임의로 데이터 유형을 정의해서 사용할 수도 있지만 MIME 문자열을 이용할 수도 있습니다.

### 드래그 피드백 이미지 설정하기
드래그가 시작되면 반투명한 이미지가 만들어져서 드래그 하는 동안 마우스를 따라다니게 됩니다. 이 이미지는 자동으로 만들어지기 때문에 굳이 따로 만들지 않아도 되지만, 원한다면 setDragImage를 사용해서 나만의 피드백 이미지를 만들 수도 있습니다.

### 드래그 & 드롭 이벤트
| dragstart | 드래그를 하고자 할 때 발생합니다. 이 이벤트가 발생하면 드래그와 관련된 정보들을 설정합니다. |
| --- | --- |
| drag | 마우스가 움직일 때 발생하며 드래그 되는 요소가 이벤트 대상입니다. |
| dragenter | 드래그된 요소가 드롭할 위치로 옮겨질 때 발생합니다. 이 이벤트에 대한 핸들러는 이 위치로 드롭을 허용할 것인지 여부를 결정해야 합니다. 기본으로는 드롭이 허용되지 않습니다. |
| dragover | 드롭 대상 위치로 옮겨지고 있을 때 발생합니다. 대부분 기본 동작은 dragenter와 같습니다. |
| dragleave | 드래그 되는 요소가 드롭 대상 영역을 벗어나서 이동할 때 발생합니다. 따라서 삽입 표시나 하이라이트 표시 등을 삭제해야 합니다. |
| drop | 성공적으로 드롭 대상 영역 위에 드롭 되었을 때 발생합니다. 드롭 위치에서 드래그 될 데이터 위치를 검색하고 삽입해야 합니다. 사용자가 esc 키를 누르거나 해서 동작을 취소하면 이 이벤트는 발생하지 않습니다. |
| dragend | 성공이든 실패든 드래그가 끝났을 때 발생합니다. |

## 08-2. 애플리케이션 캐시

### 캐시 인터페이스가 필요한 이유
오프라인 상태에서도 애플리케이션이 실행되도록 하기 위해서 필요한 것이 애플리케이션 캐시(Application Cache) 기능입니다.

#### 캐시 인터페이스의 장점
| 오프라인 브라우징 | 오프라인 상태에서도 사이트를 둘러볼 수 있습니다. |
| --- | --- |
| 속도 | 캐시된 리소스들이 로컬에 있기 때문에 더 빠르게 로딩할 수 있습니다. |
| 서버 로딩 줄임 | 리소스 변경이 있을 때에만 서버에서 다운로드 합니다. |

애플리케이션 캐시 기능은 크게 manifest 파일과 자바스크립트 인터페이스로 나눌 수 있습니다.

| manifest 파일 | 캐시해야 할 리소스들을 나열한 텍스트 파일 |
| --- | --- |
| 자바스크립트 | 캐시한 파일을 실행하고 업데이트할 수 있도록 프로그래밍 된 인터페이스 |

### manifest 파일 작성
manifest 파일은 애플리케이션에 .manifest 확장자로 다운로드 되어 저장됩니다. 일단 웹 페이지가 로딩되면 manifest에 명시된 리소스들은 웹 서버가 아닌 애플리케이션 캐시로부터 가져옵니다.

```
CACHE MANIFEST

# VERSION 10

NETWORK:
http://abcd.com/offline.html

CACHE:
offline.html
base.css

FALLBACK:
online.css offline.css
```

### manifest 파일 선언하기
HTML 파일 안에서 manifest 파일을 선언해야 그 파일을 사용할 수 있습니다. 다음과 같이 선언할 수 있습니다:

```html
<html manifest="offline.manifest">
```

대부분의 경우 manifest 파일을 만들고 선언하는 것으로 애플리케이션 캐시를 만드는 것이 끝납니다. 그리고 애플리케이션 캐시가 일단 만들어지면, 한 번 로딩된 이후부터는 자동으로 리소스가 캐시에 저장되며 브라우저 세션 때마다 캐시에서 로딩됩니다.

### 캐시 자동 업데이트
다음의 경우에는 캐시 업데이트가 되지 않습니다:

1. manifest 파일에 나열되어 있는 리소스 파일이 수정되었을 때는 업데이트 되지 않습니다. 리소스 파일은 manifest 파일과는 상관 없기 때문입니다.
2. 이전 버전과 비교해서 manifest 파일 내용이 달라진게 없다면 업데이트 되지 않습니다.
3. manifest 파일의 수정 날짜를 바꾸어도 업데이트 되지 않습니다.

만약 캐시를 업데이트 하고 싶다면 manifest 파일의 주석 내용을 살짝 바꾸는 방법이 있습니다.

### 자바스크립트를 이용한 캐시 수동 업데이트
window.applicationCache 객체를 이용해서 애플리케이션 캐시에 접근하고 status 프로퍼티를 통해 캐시의 상태를 체크할 수 있습니다:

| UNCACHED | 캐시가 완전히 초기화 되지 않음 |
| --- | --- |
| IDLE | 캐시가 아직 업데이트 되지 않음 |
| CHECKING | manifest가 패치 중이고 업데이트를 확인하는 중 |
| DOWNLOADING | 리소스 manifest가 수정되었기 때문에 캐시에 추가될 리소스를 다운로드 중입니다. |
| UPDATEREADY | 새 버전의 애플리케이션 캐시가 있습니다. 다운로드 되긴 했지만 아직 swapCache() 메서드를 사용해 활성화되지 않았습니다. |
| OBSOLETE | 캐시가 더이상 쓸모 없습니다. |

캐시의 상태를 체크한 후 UPDATEREADY 상태라면 applicationCache.update(), applicationCache.swapCache()를 통해 수동으로 업데이트할 수 있습니다.

## 08-3. 웹 스토리지 API

### 쿠키와 웹 스토리지
웹 스토리지는 나중에 사용할 수 있도록 키/값 형태의 데이터 쌍을 세션이 끝날 때까지(세션 스토리지), 또는 세션 후에도(로컬 스토리지) 저장해 두는 것입니다. 이것은 쿠키보다 훨씬 강력하며 사용도 편리합니다.

#### 쿠키의 단점
- 쿠키는 크기가 작습니다. 보통 쿠키의 최대 크기는 4KB 정도입니다.
- 같은 사이트에서 둘 이상의 탭을 열었을 때 둘 이상의 트랜젝션을 추적하기 어렵습니다.
- XSS 같은 기법을 이용해 쿠키를 오용하고 보안 문제를 일으키기 쉽습니다.

#### 웹 스토리지의 특징
쿠키와 마찬가지로 웹 사이트를 돌아보고 난 후, 브라우저 탭을 닫고 난 후, 또는 브라우저를 빠져나온 후에 저장됩니다. 하지만 쿠키와 달리 사용자가 일부러 보내지 않는 한 웹 서버로 전송되지 않습니다.

웹 스토리지는 크게 로컬 스토리지와 세션 스토리지로 나뉩니다. 두 스토리지 모두 도메인당 5MB 정도의 데이터를 저장할 수 있습니다.

### 세션 스토리지
세션 스토리지는 세션을 하는 동안의 모든 데이터를 기억하고 있다가 탭(또는 창)을 닫으면 모두 지워버립니다.

### 로컬 스토리지
로컬 스토리지는 세션이 끝나도 계속 데이터를 저장해야 할 때 사용합니다. 예를 들어 웹 사이트 방문자 수를 계산할 때는 로컬 스토리지를 사용해야 합니다.

### 스토리지 이벤트
스토리지 영역이 바뀔 때마다 스토리지 이벤트가 발생합니다.

## 08-4. Indexed DB

### 웹 데이터베이스란?
기존에는 XMLHttpRequest나 폼을 이용해 서버에 데이터를 포스팅하고 DB를 구축했지만, HTML5에서는 오프라인 캐싱을 사용하기 위해 웹 DB가 중요해졌습니다.
웹 스토리지는 단순히 웹 데이터를 저장만 하겠지만 웹 애플리케이션에서는 데이터들을 검색하고 삭제하는 관리 기능이 있는 웹 DB가 필요합니다.

### 웹 SQL DB vs Indexed DB
HTML5 워킹 그룹에서 처음 선택한 것은 웹 SQL DB였습니다. 인덱스를 생성할 수 없다는 불편함은 있어도 RDBMS를 사용하기 때문에 DB로서의 부족함은 없었습니다. SQL에 익숙한 개발자에게는 편리하지만 그렇지 않은 개발자들은 새로 SQL을 배워야 한다는 부담도 있었습니다. 이것은 표준화나 호환성 확보가 어렵다는 하나의 장애물이 되기도 했습니다.
이에 비해 Indexed DB는 '오브젝트 스토어'라는 저장 공간을 만들어두고 JS 객체를 넣거나 뺄 수 있어 쉽게 사용할 수 있습니다. 또한 인덱스르 만들어 검색하기 때문에 웹 SQL DB 보다 더 빠르게 검색할 수 있습니다.

### 알아두어야 할 개념들
Indexed DB에서 사용하는 몇 가지 용어들은 기존 DB에서 사용하는 용어들과 다릅니다:
- key: 저장된 값들 중에서 검색한 데이터 값
- in-line key: 애플리케이션에서 제공하는 키로 저장된 오브젝트의 일부인 키
- out-of-line key: 애플리케이션에서 제공하는 키로 저장된 값과 별개인 키
- index: 또 다른 오브젝트 스토어(참조되는 오브젝트 스토어라고 부름)에서 룩업 레코드로 사용하는 특별한 오브젝트 스토어. index 레코드의 value 부분은 참조되는 오브젝트 스토어 레코드의 key 부분이 됩니다.
- key path: 인라인 키이면서 자동 생성된 인덱스. 저장된 값을 가진 데이터들을 나열한 것에 이름을 붙인 것
- database connection: DB를 여는 것. DB에 동시에 여러 connection을 만들 수 있습니다.
- transaction: 특정 DB 상에서 자동 및 지속적으로 데이터에 접근하고 데이터를 수정하는 작업. DB는 한 번에 하나의 트랜잭션만 수행함.
- scope: 트랜잭션이 적용되는 오브젝트 스토어와 인덱스.
- cursor: key range에서 정의한 여러 레코드에 걸쳐 반복되는 메카니즘. position과 direction을 가짐
- key range: 키에서 사용하는 연속적인 일부 데이터들